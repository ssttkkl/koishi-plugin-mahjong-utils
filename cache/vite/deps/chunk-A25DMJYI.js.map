{
  "version": 3,
  "sources": ["../../../node_modules/cosmokit/src/misc.ts", "../../../node_modules/cosmokit/src/array.ts", "../../../node_modules/cosmokit/src/types.ts", "../../../node_modules/cosmokit/src/string.ts", "../../../node_modules/cosmokit/src/time.ts", "../../../node_modules/schemastery/src/index.ts", "../../../node_modules/schemastery-vue/src/utils.ts", "../../../node_modules/schemastery-vue/src/index.ts", "../../../node_modules/schemastery-vue/src/icons/index.ts", "../../../node_modules/@koishijs/components/client/form/index.ts", "../../../node_modules/@koishijs/components/client/virtual/index.ts", "../../../node_modules/@koishijs/components/client/index.ts"],
  "sourcesContent": ["export type Dict<T = any, K extends string = string> = { [key in K]: T }\nexport type Get<T extends {}, K> = K extends keyof T ? T[K] : never\nexport type Extract<S, T, U = S> = S extends T ? U : never\nexport type MaybeArray<T> = [T] extends [unknown[]] ? T : T | T[]\nexport type Promisify<T> = Promise<T extends Promise<infer S> ? S : T>\nexport type Awaitable<T> = [T] extends [Promise<unknown>] ? T : T | Promise<T>\nexport type Intersect<U> = (U extends any ? (arg: U) => void : never) extends ((arg: infer I) => void) ? I : never\n\nexport function noop(): any {}\n\nexport function isNullable(value: any): value is null | undefined | void {\n  return value === null || value === undefined\n}\n\nexport function isPlainObject(data: any) {\n  return data && typeof data === 'object' && !Array.isArray(data)\n}\n\nexport function filterKeys<T, K extends string, U extends K>(object: Dict<T, K>, filter: (key: K, value: T) => key is U): Dict<T, U>\nexport function filterKeys<T, K extends string>(object: Dict<T, K>, filter: (key: K, value: T) => boolean): Dict<T, K>\nexport function filterKeys(object: {}, filter: (key: string, value: any) => boolean) {\n  return Object.fromEntries(Object.entries(object).filter(([key, value]) => filter(key, value)))\n}\n\nexport function mapValues<U, T, K extends string>(object: Dict<T, K>, transform: (value: T, key: K) => U) {\n  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key, (transform as any)(value, key)])) as Dict<U, K>\n}\n\nexport { mapValues as valueMap }\n\nexport function pick<T extends object, K extends keyof T>(source: T, keys?: Iterable<K>, forced?: boolean) {\n  if (!keys) return { ...source }\n  const result = {} as Pick<T, K>\n  for (const key of keys) {\n    if (forced || source[key] !== undefined) result[key] = source[key]\n  }\n  return result\n}\n\nexport function omit<T, K extends keyof T>(source: T, keys?: Iterable<K>) {\n  if (!keys) return { ...source }\n  const result = { ...source } as Omit<T, K>\n  for (const key of keys) {\n    Reflect.deleteProperty(result, key)\n  }\n  return result\n}\n\nexport function defineProperty<T, K extends keyof T>(object: T, key: K, value: T[K]): T\nexport function defineProperty<T, K extends keyof any>(object: T, key: K, value: any): T\nexport function defineProperty<T, K extends keyof any>(object: T, key: K, value: any) {\n  return Object.defineProperty(object, key, { writable: true, value, enumerable: false })\n}\n", "import { isNullable } from './misc'\n\nexport function contain(array1: readonly any[], array2: readonly any[]) {\n  return array2.every(item => array1.includes(item))\n}\n\nexport function intersection<T>(array1: readonly T[], array2: readonly T[]) {\n  return array1.filter(item => array2.includes(item))\n}\n\nexport function difference<S>(array1: readonly S[], array2: readonly any[]) {\n  return array1.filter(item => !array2.includes(item))\n}\n\nexport function union<T>(array1: readonly T[], array2: readonly T[]) {\n  return Array.from(new Set([...array1, ...array2]))\n}\n\nexport function deduplicate<T>(array: readonly T[]) {\n  return [...new Set(array)]\n}\n\nexport function remove<T>(list: T[], item: T) {\n  const index = list.indexOf(item)\n  if (index >= 0) {\n    list.splice(index, 1)\n    return true\n  } else {\n    return false\n  }\n}\n\nexport function makeArray<T>(source: null | undefined | T | T[]) {\n  return Array.isArray(source) ? source : isNullable(source) ? [] : [source]\n}\n", "import { isNullable, mapValues } from './misc'\n\ntype GlobalConstructorNames = keyof {\n  [K in keyof typeof globalThis as typeof globalThis[K] extends abstract new (...args: any) => any ? K : never]: K\n}\n\nexport function is<K extends GlobalConstructorNames>(type: K): (value: any) => value is InstanceType<typeof globalThis[K]>\nexport function is<K extends GlobalConstructorNames>(type: K, value: any): value is InstanceType<typeof globalThis[K]>\nexport function is<K extends GlobalConstructorNames>(type: K, value?: any): any {\n  if (arguments.length === 1) return (value: any) => is(type, value)\n  return type in globalThis && value instanceof (globalThis[type] as any)\n    || Object.prototype.toString.call(value).slice(8, -1) === type\n}\n\nfunction isArrayBufferLike(value: any): value is ArrayBufferLike {\n  return is('ArrayBuffer', value) || is('SharedArrayBuffer', value)\n}\n\nfunction isArrayBufferSource(value: any): value is Binary.Source {\n  return isArrayBufferLike(value) || ArrayBuffer.isView(value)\n}\n\nexport namespace Binary {\n  export type Source = ArrayBufferLike | ArrayBufferView\n\n  export const is = isArrayBufferLike\n  export const isSource = isArrayBufferSource\n\n  export function fromSource(source: Source) {\n    if (ArrayBuffer.isView(source)) {\n      // https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer#answer-31394257\n      return source.buffer.slice(source.byteOffset, source.byteOffset + source.byteLength)\n    } else {\n      return source\n    }\n  }\n\n  export function toBase64(source: ArrayBufferLike) {\n    if (typeof Buffer !== 'undefined') {\n      return Buffer.from(source).toString('base64')\n    }\n    let binary = ''\n    const bytes = new Uint8Array(source)\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i])\n    }\n    return btoa(binary)\n  }\n\n  export function fromBase64(source: string) {\n    if (typeof Buffer !== 'undefined') return fromSource(Buffer.from(source, 'base64'))\n    return Uint8Array.from(atob(source), c => c.charCodeAt(0))\n  }\n\n  export function toHex(source: ArrayBufferLike) {\n    if (typeof Buffer !== 'undefined') return Buffer.from(source).toString('hex')\n    return Array.from(new Uint8Array(source), byte => byte.toString(16).padStart(2, '0')).join('')\n  }\n\n  export function fromHex(source: string) {\n    if (typeof Buffer !== 'undefined') return fromSource(Buffer.from(source, 'hex'))\n    const hex = source.length % 2 === 0 ? source : source.slice(0, source.length - 1)\n    const buffer: number[] = []\n    for (let i = 0; i < hex.length; i += 2) {\n      buffer.push(parseInt(`${hex[i]}${hex[i + 1]}`, 16))\n    }\n    return Uint8Array.from(buffer).buffer\n  }\n}\n\nexport const base64ToArrayBuffer = Binary.fromBase64\nexport const arrayBufferToBase64 = Binary.toBase64\nexport const hexToArrayBuffer = Binary.fromHex\nexport const arrayBufferToHex = Binary.toHex\n\nexport function clone<T>(source: T): T\nexport function clone(source: any) {\n  if (!source || typeof source !== 'object') return source\n  if (Array.isArray(source)) return source.map(clone)\n  if (is('Date', source)) return new Date(source.valueOf())\n  if (is('RegExp', source)) return new RegExp(source.source, source.flags)\n  if (isArrayBufferLike(source)) return source.slice(0)\n  if (ArrayBuffer.isView(source)) return source.buffer.slice(source.byteOffset, source.byteOffset + source.byteLength)\n  return mapValues(source, clone)\n}\n\nexport function deepEqual(a: any, b: any, strict?: boolean): boolean {\n  if (a === b) return true\n  if (!strict && isNullable(a) && isNullable(b)) return true\n  if (typeof a !== typeof b) return false\n  if (typeof a !== 'object') return false\n  if (!a || !b) return false\n\n  function check<T>(test: (x: any) => x is T, then: (a: T, b: T) => boolean) {\n    return test(a) ? test(b) ? then(a, b) : false : test(b) ? false : undefined\n  }\n\n  return check(Array.isArray, (a, b) => a.length === b.length && a.every((item, index) => deepEqual(item, b[index])))\n    ?? check(is('Date'), (a, b) => a.valueOf() === b.valueOf())\n    ?? check(is('RegExp'), (a, b) => a.source === b.source && a.flags === b.flags)\n    ?? check(isArrayBufferLike, (a, b) => {\n      if (a.byteLength !== b.byteLength) return false\n      const viewA = new Uint8Array(a)\n      const viewB = new Uint8Array(b)\n      for (let i = 0; i < viewA.length; i++) {\n        if (viewA[i] !== viewB[i]) return false\n      }\n      return true\n    })\n    ?? Object.keys({ ...a, ...b }).every(key => deepEqual(a[key], b[key], strict))\n}\n", "export function capitalize(source: string) {\n  return source.charAt(0).toUpperCase() + source.slice(1)\n}\n\nexport function uncapitalize(source: string) {\n  return source.charAt(0).toLowerCase() + source.slice(1)\n}\n\nexport function camelCase(source: string) {\n  return source.replace(/[_-][a-z]/g, str => str.slice(1).toUpperCase())\n}\n\nexport function paramCase(source: string) {\n  // do not use lookbehind assertion for Safari compatibility\n  return uncapitalize(source)\n    .replace(/_/g, '-')\n    .replace(/.[A-Z]+/g, str => str[0] + '-' + str.slice(1).toLowerCase())\n}\n\nexport function snakeCase(source: string) {\n  // do not use lookbehind assertion for Safari compatibility\n  return uncapitalize(source)\n    .replace(/-/g, '_')\n    .replace(/.[A-Z]+/g, str => str[0] + '_' + str.slice(1).toLowerCase())\n}\n\nexport const camelize = camelCase\nexport const hyphenate = paramCase\n\nnamespace Letter {\n  /* eslint-disable @typescript-eslint/member-delimiter-style */\n  interface LowerToUpper {\n    a: 'A', b: 'B', c: 'C', d: 'D', e: 'E', f: 'F', g: 'G', h: 'H', i: 'I', j: 'J', k: 'K', l: 'L', m: 'M',\n    n: 'N', o: 'O', p: 'P', q: 'Q', r: 'R', s: 'S', t: 'T', u: 'U', v: 'V', w: 'W', x: 'X', y: 'Y', z: 'Z',\n  }\n\n  interface UpperToLower {\n    A: 'a', B: 'b', C: 'c', D: 'd', E: 'e', F: 'f', G: 'g', H: 'h', I: 'i', J: 'j', K: 'k', L: 'l', M: 'm',\n    N: 'n', O: 'o', P: 'p', Q: 'q', R: 'r', S: 's', T: 't', U: 'u', V: 'v', W: 'w', X: 'x', Y: 'y', Z: 'z',\n  }\n  /* eslint-enable @typescript-eslint/member-delimiter-style */\n\n  export type Upper = keyof UpperToLower\n  export type Lower = keyof LowerToUpper\n\n  export type ToUpper<S extends string> = S extends Lower ? LowerToUpper[S] : S\n  export type ToLower<S extends string, P extends string = ''> = S extends Upper ? `${P}${UpperToLower[S]}` : S\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport type camelize<S extends string> = S extends `${infer L}-${infer M}${infer R}` ? `${L}${Letter.ToUpper<M>}${camelize<R>}` : S\nexport type hyphenate<S extends string> = S extends `${infer L}${infer R}` ? `${Letter.ToLower<L, '-'>}${hyphenate<R>}` : S\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport function trimSlash(source: string) {\n  return source.replace(/\\/$/, '')\n}\n\nexport function sanitize(source: string) {\n  if (!source.startsWith('/')) source = '/' + source\n  return trimSlash(source)\n}\n", "export namespace Time {\n  export const millisecond = 1\n  export const second = 1000\n  export const minute = second * 60\n  export const hour = minute * 60\n  export const day = hour * 24\n  export const week = day * 7\n\n  let timezoneOffset = new Date().getTimezoneOffset()\n\n  export function setTimezoneOffset(offset: number) {\n    timezoneOffset = offset\n  }\n\n  export function getTimezoneOffset() {\n    return timezoneOffset\n  }\n\n  export function getDateNumber(date: number | Date = new Date(), offset?: number) {\n    if (typeof date === 'number') date = new Date(date)\n    if (offset === undefined) offset = timezoneOffset\n    return Math.floor((date.valueOf() / minute - offset) / 1440)\n  }\n\n  export function fromDateNumber(value: number, offset?: number) {\n    const date = new Date(value * day)\n    if (offset === undefined) offset = timezoneOffset\n    return new Date(+date + offset * minute)\n  }\n\n  const numeric = /\\d+(?:\\.\\d+)?/.source\n  const timeRegExp = new RegExp(`^${[\n    'w(?:eek(?:s)?)?',\n    'd(?:ay(?:s)?)?',\n    'h(?:our(?:s)?)?',\n    'm(?:in(?:ute)?(?:s)?)?',\n    's(?:ec(?:ond)?(?:s)?)?',\n  ].map(unit => `(${numeric}${unit})?`).join('')}$`)\n\n  export function parseTime(source: string) {\n    const capture = timeRegExp.exec(source)\n    if (!capture) return 0\n    return (parseFloat(capture[1]) * week || 0)\n      + (parseFloat(capture[2]) * day || 0)\n      + (parseFloat(capture[3]) * hour || 0)\n      + (parseFloat(capture[4]) * minute || 0)\n      + (parseFloat(capture[5]) * second || 0)\n  }\n\n  export function parseDate(date: string) {\n    const parsed = parseTime(date)\n    if (parsed) {\n      date = Date.now() + parsed as any\n    } else if (/^\\d{1,2}(:\\d{1,2}){1,2}$/.test(date)) {\n      date = `${new Date().toLocaleDateString()}-${date}`\n    } else if (/^\\d{1,2}-\\d{1,2}-\\d{1,2}(:\\d{1,2}){1,2}$/.test(date)) {\n      date = `${new Date().getFullYear()}-${date}`\n    }\n    return date ? new Date(date) : new Date()\n  }\n\n  export function format(ms: number) {\n    const abs = Math.abs(ms)\n    if (abs >= day - hour / 2) {\n      return Math.round(ms / day) + 'd'\n    } else if (abs >= hour - minute / 2) {\n      return Math.round(ms / hour) + 'h'\n    } else if (abs >= minute - second / 2) {\n      return Math.round(ms / minute) + 'm'\n    } else if (abs >= second) {\n      return Math.round(ms / second) + 's'\n    }\n    return ms + 'ms'\n  }\n\n  export function toDigits(source: number, length = 2) {\n    return source.toString().padStart(length, '0')\n  }\n\n  export function template(template: string, time = new Date()) {\n    return template\n      .replace('yyyy', time.getFullYear().toString())\n      .replace('yy', time.getFullYear().toString().slice(2))\n      .replace('MM', toDigits(time.getMonth() + 1))\n      .replace('dd', toDigits(time.getDate()))\n      .replace('hh', toDigits(time.getHours()))\n      .replace('mm', toDigits(time.getMinutes()))\n      .replace('ss', toDigits(time.getSeconds()))\n      .replace('SSS', toDigits(time.getMilliseconds(), 3))\n  }\n}\n", "import { clone, deepEqual, Dict, filterKeys, isNullable, isPlainObject, pick, valueMap } from 'cosmokit'\n\nconst kSchema = Symbol.for('schemastery')\n\ndeclare global {\n  namespace Schemastery {\n    export type From<X> =\n      | X extends string | number | boolean ? Schema<X>\n      : X extends Schema ? X\n      : X extends typeof String ? Schema<string>\n      : X extends typeof Number ? Schema<number>\n      : X extends typeof Boolean ? Schema<boolean>\n      : X extends typeof Function ? Schema<Function, (...args: any[]) => any>\n      : X extends Constructor<infer S> ? Schema<S>\n      : never\n\n    type TypeS1<X> = X extends Schema<infer S, unknown> ? S : never\n    type Inverse<X> = X extends Schema<any, infer Y> ? (arg: Y) => void : never\n\n    export type TypeS<X> = TypeS1<From<X>>\n    export type TypeT<X> = ReturnType<From<X>>\n    export type Resolve = (data: any, schema: Schema, options?: Options, strict?: boolean) => [any, any?]\n\n    export type IntersectS<X> = From<X> extends Schema<infer S, unknown> ? S : never\n    export type IntersectT<X> = Inverse<From<X>> extends ((arg: infer T) => void) ? T : never\n\n    type TupleS<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeS<L>?, ...TupleS<R>] : any[]\n    type TupleT<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeT<L>?, ...TupleT<R>] : any[]\n    type ObjectS<X extends Dict> = { [K in keyof X]?: TypeS<X[K]> | null } & Dict\n    type ObjectT<X extends Dict> = { [K in keyof X]: TypeT<X[K]> } & Dict\n    type Constructor<T = any> = new (...args: any[]) => T\n\n    export interface Static {\n      <T = any>(options: Partial<Schema<T>>): Schema<T>\n      new <T = any>(options: Partial<Schema<T>>): Schema<T>\n      prototype: Schema\n      resolve: Resolve\n      from<X = any>(source?: X): From<X>\n      extend(type: string, resolve: Resolve): void\n      any(): Schema<any>\n      never(): Schema<never>\n      const<const T>(value: T): Schema<T>\n      string(): Schema<string>\n      number(): Schema<number>\n      natural(): Schema<number>\n      percent(): Schema<number>\n      boolean(): Schema<boolean>\n      date(): Schema<string | Date, Date>\n      bitset<K extends string>(bits: Partial<Record<K, number>>): Schema<number | readonly K[], number>\n      function(): Schema<Function, (...args: any[]) => any>\n      is<T>(constructor: Constructor<T>): Schema<T>\n      array<X>(inner: X): Schema<TypeS<X>[], TypeT<X>[]>\n      dict<X, Y extends Schema<any, string> = Schema<string>>(inner: X, sKey?: Y): Schema<Dict<TypeS<X>, TypeS<Y>>, Dict<TypeT<X>, TypeT<Y>>>\n      tuple<X extends readonly any[]>(list: X): Schema<TupleS<X>, TupleT<X>>\n      object<X extends Dict>(dict: X): Schema<ObjectS<X>, ObjectT<X>>\n      union<const X>(list: readonly X[]): Schema<TypeS<X>, TypeT<X>>\n      intersect<const X>(list: readonly X[]): Schema<IntersectS<X>, IntersectT<X>>\n      transform<X, T>(inner: X, callback: (value: TypeS<X>) => T, preserve?: boolean): Schema<TypeS<X>, T>\n    }\n\n    interface Options {\n      autofix?: boolean\n    }\n\n    export interface Meta<T = any> {\n      default?: T extends {} ? Partial<T> : T\n      required?: boolean\n      disabled?: boolean\n      collapse?: boolean\n      badges?: { text: string; type: string }[]\n      hidden?: boolean\n      loose?: boolean\n      role?: string\n      extra?: any\n      link?: string\n      description?: string | Dict<string>\n      comment?: string\n      pattern?: { source: string; flags?: string }\n      max?: number\n      min?: number\n      step?: number\n    }\n  }\n\n  interface Schemastery<S = any, T = S> {\n    (data?: S | null, options?: Schemastery.Options): T\n    new (data?: S | null, options?: Schemastery.Options): T\n    [kSchema]: true\n    uid: number\n    meta: Schemastery.Meta<T>\n    type: string\n    sKey?: Schema\n    inner?: Schema\n    list?: Schema[]\n    dict?: Dict<Schema>\n    bits?: Dict<number>\n    callback?: Function\n    value?: T\n    refs?: Dict<Schema>\n    preserve?: boolean\n    toString(inline?: boolean): string\n    toJSON(): Schema<S, T>\n    required(value?: boolean): Schema<S, T>\n    hidden(value?: boolean): Schema<S, T>\n    loose(value?: boolean): Schema<S, T>\n    role(text: string, extra?: any): Schema<S, T>\n    link(link: string): Schema<S, T>\n    default(value: T): Schema<S, T>\n    comment(text: string): Schema<S, T>\n    description(text: string): Schema<S, T>\n    disabled(value?: boolean): Schema<S, T>\n    collapse(value?: boolean): Schema<S, T>\n    deprecated(): Schema<S, T>\n    experimental(): Schema<S, T>\n    pattern(regexp: RegExp): Schema<S, T>\n    max(value: number): Schema<S, T>\n    min(value: number): Schema<S, T>\n    step(value: number): Schema<S, T>\n    set(key: string, value: Schema): Schema<S, T>\n    push(value: Schema): Schema<S, T>\n    simplify(value?: any): any\n    i18n(messages: Dict): Schema<S, T>\n    extra<K extends keyof Schemastery.Meta>(key: K, value: Schemastery.Meta[K]): Schema<S, T>\n  }\n}\n\ndeclare module globalThis {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  export let __schemastery_index__: number\n}\n\nglobalThis.__schemastery_index__ ??= 0\n\ntype Schema<S = any, T = S> = Schemastery<S, T>\n\nconst Schema = function (options: Schema) {\n  const schema = function (data: any, options?: Schemastery.Options) {\n    return Schema.resolve(data, schema, options)[0]\n  } as Schema\n\n  if (options.refs) {\n    const refs = valueMap(options.refs, options => new Schema(options))\n    const getRef = (uid: any) => refs[uid]!\n    for (const key in refs) {\n      const options = refs[key]!\n      options.sKey = getRef(options.sKey)\n      options.inner = getRef(options.inner)\n      options.list = options.list && options.list.map(getRef)\n      options.dict = options.dict && valueMap(options.dict, getRef)\n    }\n    return refs[options.uid!]\n  }\n\n  Object.assign(schema, options)\n  if (typeof schema.callback === 'string') {\n    try {\n      // eslint-disable-next-line no-new-func\n      schema.callback = new Function('return ' + schema.callback)()\n    } catch {}\n  }\n  Object.defineProperty(schema, 'uid', { value: globalThis.__schemastery_index__++ })\n  Object.setPrototypeOf(schema, Schema.prototype)\n  schema.meta ||= {}\n  schema.toString = schema.toString.bind(schema)\n  return schema\n} as Schemastery.Static\n\nSchema.prototype = Object.create(Function.prototype)\n\nSchema.prototype[kSchema] = true\n\nlet refs: Record<number, Schema> | undefined\n\nSchema.prototype.toJSON = function toJSON() {\n  if (refs) {\n    refs[this.uid] ??= JSON.parse(JSON.stringify({ ...this }))\n    return this.uid as any\n  }\n\n  refs = { [this.uid]: { ...this } as Schema }\n  refs[this.uid] = JSON.parse(JSON.stringify({ ...this }))\n  const result = { uid: this.uid, refs }\n  refs = undefined\n  return result\n}\n\nSchema.prototype.set = function set(key, value) {\n  this.dict![key] = value\n  return this\n}\n\nSchema.prototype.push = function push(value) {\n  this.list!.push(value)\n  return this\n}\n\nfunction mergeDesc(original: undefined | string | Dict<string>, messages: Dict) {\n  const result: Dict<string> = typeof original === 'string' ? { '': original } : { ...original }\n  for (const locale in messages) {\n    const value = messages[locale]\n    if (value?.$description || value?.$desc) {\n      result[locale] = value.$description || value.$desc\n    } else if (typeof value === 'string') {\n      result[locale] = value\n    }\n  }\n  return result\n}\n\nfunction getInner(value: any) {\n  return value?.$value ?? value?.$inner\n}\n\nfunction extractKeys(data: any) {\n  return filterKeys(data ?? {}, key => !key.startsWith('$'))\n}\n\nSchema.prototype.i18n = function i18n(messages) {\n  const schema = Schema(this)\n  schema.meta.description = mergeDesc(schema.meta.description, messages)\n  if (schema.dict) {\n    schema.dict = valueMap(schema.dict, (inner, key) => {\n      return inner.i18n(valueMap(messages, (data) => getInner(data)?.[key] ?? data?.[key]))\n    })\n  }\n  if (schema.list) {\n    schema.list = schema.list!.map((inner, index) => {\n      return inner.i18n(valueMap(messages, (data = {}) => {\n        if (Array.isArray(getInner(data))) return getInner(data)[index]\n        if (Array.isArray(data)) return data[index]\n        return extractKeys(data)\n      }))\n    })\n  }\n  if (schema.inner) {\n    schema.inner = schema.inner.i18n(valueMap(messages, (data) => {\n      if (getInner(data)) return getInner(data)\n      return extractKeys(data)\n    }))\n  }\n  if (schema.sKey) {\n    schema.sKey = schema.sKey.i18n(valueMap(messages, (data) => data?.$key))\n  }\n  return schema\n}\n\nSchema.prototype.extra = function extra(key, value) {\n  const schema = Schema(this)\n  schema.meta = { ...schema.meta, [key]: value }\n  return schema\n}\n\nfor (const key of ['required', 'disabled', 'collapse', 'hidden', 'loose']) {\n  Object.assign(Schema.prototype, {\n    [key](this: Schema, value = true) {\n      const schema = Schema(this)\n      schema.meta = { ...schema.meta, [key]: value }\n      return schema\n    },\n  })\n}\n\nSchema.prototype.deprecated = function deprecated() {\n  const schema = Schema(this)\n  schema.meta.badges ||= []\n  schema.meta.badges.push({ text: 'deprecated', type: 'danger' })\n  return schema\n}\n\nSchema.prototype.experimental = function experimental() {\n  const schema = Schema(this)\n  schema.meta.badges ||= []\n  schema.meta.badges.push({ text: 'experimental', type: 'warning' })\n  return schema\n}\n\nSchema.prototype.pattern = function pattern(regexp) {\n  const schema = Schema(this)\n  const pattern = pick(regexp, ['source', 'flags'])\n  schema.meta = { ...schema.meta, pattern }\n  return schema\n}\n\nSchema.prototype.simplify = function simplify(this: Schema, value) {\n  if (deepEqual(value, this.meta.default, this.type === 'dict')) return null\n  if (isNullable(value)) return value\n  if (this.type === 'object' || this.type === 'dict') {\n    const result: Dict = {}\n    for (const key in value) {\n      const schema = this.type === 'object' ? this.dict![key] : this.inner\n      const item = schema?.simplify(value[key])\n      if (this.type === 'dict' || !isNullable(item)) result[key] = item\n    }\n    if (deepEqual(result, this.meta.default, this.type === 'dict')) return null\n    return result\n  } else if (this.type === 'array' || this.type === 'tuple') {\n    const result: any[] = []\n    ;(value as any[]).forEach((value, index) => {\n      const schema = this.type === 'array' ? this.inner : this.list![index]\n      const item = schema ? schema.simplify(value) : value\n      result.push(item)\n    })\n    return result\n  } else if (this.type === 'intersect') {\n    const result: Dict = {}\n    for (const item of this.list!) {\n      Object.assign(result, item.simplify(value))\n    }\n    return result\n  } else if (this.type === 'union') {\n    for (const schema of this.list!) {\n      try {\n        Schema.resolve(value, schema)\n        return schema.simplify(value)\n      } catch {}\n    }\n  }\n  return value\n}\n\nSchema.prototype.toString = function toString(inline?: boolean) {\n  return formatters[this.type]?.(this, inline) ?? `Schema<${this.type}>`\n}\n\nSchema.prototype.role = function role(role, extra) {\n  const schema = Schema(this)\n  schema.meta = { ...schema.meta, role, extra }\n  return schema\n}\n\nfor (const key of ['default', 'link', 'comment', 'description', 'max', 'min', 'step']) {\n  Object.assign(Schema.prototype, {\n    [key](this: Schema, value: any) {\n      const schema = Schema(this)\n      schema.meta = { ...schema.meta, [key]: value }\n      return schema\n    },\n  })\n}\n\nconst resolvers: Dict<Schemastery.Resolve> = {}\n\nSchema.extend = function extend(type, resolve) {\n  resolvers[type] = resolve\n}\n\nSchema.resolve = function resolve(data, schema, options = {}, strict = false) {\n  if (!schema) return [data]\n\n  if (isNullable(data)) {\n    if (schema.meta.required) throw new TypeError(`missing required value`)\n    let current = schema\n    let fallback = schema.meta.default\n    while (current?.type === 'intersect' && isNullable(fallback)) {\n      current = current.list![0]\n      fallback = current?.meta.default\n    }\n    if (isNullable(fallback)) return [data]\n    data = clone(fallback)\n  }\n\n  const callback = resolvers[schema.type]\n  if (!callback) throw new TypeError(`unsupported type \"${schema.type}\"`)\n\n  try {\n    return callback(data, schema, options, strict)\n  } catch (error) {\n    if (!schema.meta.loose) throw error\n    return [schema.meta.default]\n  }\n}\n\nSchema.from = function from(source: any) {\n  if (isNullable(source)) {\n    return Schema.any()\n  } else if (['string', 'number', 'boolean'].includes(typeof source)) {\n    return Schema.const(source).required()\n  } else if (source[kSchema]) {\n    return source\n  } else if (typeof source === 'function') {\n    switch (source) {\n      case String: return Schema.string().required()\n      case Number: return Schema.number().required()\n      case Boolean: return Schema.boolean().required()\n      case Function: return Schema.function().required()\n      default: return Schema.is(source).required()\n    }\n  } else {\n    throw new TypeError(`cannot infer schema from ${source}`)\n  }\n}\n\nSchema.natural = function natural() {\n  return Schema.number().step(1).min(0)\n}\n\nSchema.percent = function percent() {\n  return Schema.number().step(0.01).min(0).max(1).role('slider')\n}\n\nSchema.date = function date() {\n  return Schema.union([\n    Schema.is(Date),\n    Schema.transform(Schema.string().role('datetime'), (value) => {\n      const date = new Date(value)\n      if (isNaN(+date)) throw new TypeError(`invalid date \"${value}\"`)\n      return date\n    }, true),\n  ])\n}\n\nSchema.extend('any', (data) => {\n  return [data]\n})\n\nSchema.extend('never', (data) => {\n  throw new TypeError(`expected nullable but got ${data}`)\n})\n\nSchema.extend('const', (data, { value }) => {\n  if (data === value) return [value]\n  throw new TypeError(`expected ${value} but got ${data}`)\n})\n\nfunction checkWithinRange(data: number, meta: Schemastery.Meta<any>, description: string, skipMin = false) {\n  const { max = Infinity, min = -Infinity } = meta\n  if (data > max) throw new TypeError(`expected ${description} <= ${max} but got ${data}`)\n  if (data < min && !skipMin) throw new TypeError(`expected ${description} >= ${min} but got ${data}`)\n}\n\nSchema.extend('string', (data, { meta }) => {\n  if (typeof data !== 'string') throw new TypeError(`expected string but got ${data}`)\n  if (meta.pattern) {\n    const regexp = new RegExp(meta.pattern.source, meta.pattern.flags)\n    if (!regexp.test(data)) throw new TypeError(`expect string to match regexp ${regexp}`)\n  }\n  checkWithinRange(data.length, meta, 'string length')\n  return [data]\n})\n\nfunction decimalShift(data: number, digits: number) {\n  const str = data.toString()\n  if (str.includes('e')) return data * Math.pow(10, digits)\n  const index = str.indexOf('.')\n  if (index === -1) return data * Math.pow(10, digits)\n  const frac = str.slice(index + 1)\n  const integer = str.slice(0, index)\n  if (frac.length <= digits) return +(integer + frac.padEnd(digits, '0'))\n  return +(integer + frac.slice(0, digits) + '.' + frac.slice(digits))\n}\n\nfunction isMultipleOf(data: number, min: number, step: number) {\n  step = Math.abs(step)\n  if (!/^\\d+\\.\\d+$/.test(step.toString())) {\n    return (data - min) % step === 0\n  }\n  const index = step.toString().indexOf('.')\n  const digits = step.toString().slice(index + 1).length\n  return Math.abs(decimalShift(data, digits) - decimalShift(min, digits)) % decimalShift(step, digits) === 0\n}\n\nSchema.extend('number', (data, { meta }) => {\n  if (typeof data !== 'number') throw new TypeError(`expected number but got ${data}`)\n  checkWithinRange(data, meta, 'number')\n  const { step } = meta\n  if (step && !isMultipleOf(data, meta.min ?? 0, step)) {\n    throw new TypeError(`expected number multiple of ${step} but got ${data}`)\n  }\n  return [data]\n})\n\nSchema.extend('boolean', (data) => {\n  if (typeof data === 'boolean') return [data]\n  throw new TypeError(`expected boolean but got ${data}`)\n})\n\nSchema.extend('bitset', (data, { bits, meta }) => {\n  let value = 0, keys: string[] = []\n  if (typeof data === 'number') {\n    value = data\n    for (const key in bits!) {\n      if (data & bits![key]!) {\n        keys.push(key)\n      }\n    }\n  } else if (Array.isArray(data)) {\n    keys = data\n    for (const key of keys) {\n      if (typeof key !== 'string') throw new TypeError(`expected string but got ${key}`)\n      if (key in bits!) value |= bits![key]!\n    }\n  } else {\n    throw new TypeError(`expected number or array but got ${data}`)\n  }\n  if (value === meta.default) return [value]\n  return [value, keys]\n})\n\nSchema.extend('function', (data) => {\n  if (typeof data === 'function') return [data]\n  throw new TypeError(`expected function but got ${data}`)\n})\n\nSchema.extend('is', (data, { callback }) => {\n  if (data instanceof callback!) return [data]\n  throw new TypeError(`expected ${callback!.name} but got ${data}`)\n})\n\nfunction property(data: any, key: keyof any, schema: Schema, options?: Schemastery.Options) {\n  try {\n    const [value, adapted] = Schema.resolve(data[key], schema, options)\n    if (adapted !== undefined) data[key] = adapted\n    return value\n  } catch (e) {\n    if (!options?.autofix) throw e\n    delete data[key]\n    return schema.meta.default\n  }\n}\n\nSchema.extend('array', (data, { inner, meta }, options) => {\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  checkWithinRange(data.length, meta, 'array length', !isNullable(inner!.meta.default))\n  return [data.map((_, index) => property(data, index, inner!, options))]\n})\n\nSchema.extend('dict', (data, { inner, sKey }, options, strict) => {\n  if (!isPlainObject(data)) throw new TypeError(`expected object but got ${data}`)\n  const result: any = {}\n  for (const key in data) {\n    let rKey: string\n    try {\n      rKey = Schema.resolve(key, sKey!)[0]\n    } catch (error) {\n      if (strict) continue\n      throw error\n    }\n    result[rKey] = property(data, key, inner!, options)\n    data[rKey] = data[key]\n    if (key !== rKey) delete data[key]\n  }\n  return [result]\n})\n\nSchema.extend('tuple', (data, { list }, options, strict) => {\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  const result = list!.map((inner, index) => property(data, index, inner, options))\n  if (strict) return [result]\n  result.push(...data.slice(list!.length))\n  return [result]\n})\n\nfunction merge(result: any, data: any) {\n  for (const key in data) {\n    if (key in result) continue\n    result[key] = data[key]\n  }\n}\n\nSchema.extend('object', (data, { dict }, options, strict) => {\n  if (!isPlainObject(data)) throw new TypeError(`expected object but got ${data}`)\n  const result: any = {}\n  for (const key in dict) {\n    const value = property(data, key, dict![key]!, options)\n    if (!isNullable(value) || key in data) {\n      result[key] = value\n    }\n  }\n  if (!strict) merge(result, data)\n  return [result]\n})\n\nSchema.extend('union', (data, { list, toString }, options, strict) => {\n  const messages: any[] = []\n  for (const inner of list!) {\n    try {\n      return Schema.resolve(data, inner, options, strict)\n    } catch (error) {\n      messages.push(error)\n    }\n  }\n  throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n})\n\nSchema.extend('intersect', (data, { list, toString }, options, strict) => {\n  let result\n  for (const inner of list!) {\n    const value: any = Schema.resolve(data, inner, options, true)[0]\n    if (isNullable(value)) continue\n    if (isNullable(result)) {\n      result = value\n    } else if (typeof result !== typeof value) {\n      throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n    } else if (typeof value === 'object') {\n      merge(result ??= {}, value)\n    } else if (result !== value) {\n      throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n    }\n  }\n  if (!strict && isPlainObject(data)) merge(result, data)\n  return [result]\n})\n\nSchema.extend('transform', (data, { inner, callback, preserve }, options) => {\n  const [result, adapted = data] = Schema.resolve(data, inner!, options, true)\n  if (preserve) {\n    return [callback!(result)]\n  // } else if (isPlainObject(data)) {\n  //   const temp: any = {}\n  //   for (const key in result) {\n  //     if (!(key in data)) continue\n  //     temp[key] = data[key]\n  //     delete data[key]\n  //   }\n  //   Object.assign(data, callback!(temp))\n  //   return [callback!(result)]\n  } else {\n    return [callback!(result), callback!(adapted)]\n  }\n})\n\ntype Formatter = (schema: Schema, inline?: boolean) => string\nconst formatters: Dict<Formatter> = {}\n\nfunction defineMethod(name: string, keys: (keyof Schema)[], format: Formatter) {\n  formatters[name] = format\n  Object.assign(Schema, {\n    [name](...args: any[]) {\n      const schema = new Schema({ type: name } as Schema)\n      keys.forEach((key, index) => {\n        switch (key) {\n          case 'sKey': schema.sKey = args[index] ?? Schema.string(); break\n          case 'inner': schema.inner = Schema.from(args[index]); break\n          case 'list': schema.list = args[index].map(Schema.from); break\n          case 'dict': schema.dict = valueMap(args[index], Schema.from); break\n          case 'bits': {\n            schema.bits = {}\n            for (const key in args[index]) {\n              if (typeof args[index][key] !== 'number') continue\n              schema.bits[key] = args[index][key]\n            }\n            break\n          }\n          case 'callback': {\n            schema.callback = args[index]\n            ;(schema.callback as any)['toJSON'] ||= () => schema.callback!.toString()\n            break\n          }\n          default: schema[key] = args[index] as never\n        }\n      })\n      if (name === 'object' || name === 'dict') {\n        schema.meta.default = {}\n      } else if (name === 'array' || name === 'tuple') {\n        schema.meta.default = []\n      } else if (name === 'bitset') {\n        schema.meta.default = 0\n      }\n      return schema\n    },\n  })\n}\n\ndefineMethod('is', ['callback'], ({ callback }) => callback!.name)\ndefineMethod('any', [], () => 'any')\ndefineMethod('never', [], () => 'never')\ndefineMethod('const', ['value'], ({ value }) => typeof value === 'string' ? JSON.stringify(value) : value)\ndefineMethod('string', [], () => 'string')\ndefineMethod('number', [], () => 'number')\ndefineMethod('boolean', [], () => 'boolean')\ndefineMethod('bitset', ['bits'], () => 'bitset')\ndefineMethod('function', [], () => 'function')\ndefineMethod('array', ['inner'], ({ inner }) => `${inner!.toString(true)}[]`)\ndefineMethod('dict', ['inner', 'sKey'], ({ inner, sKey }) => `{ [key: ${sKey!.toString()}]: ${inner!.toString()} }`)\ndefineMethod('tuple', ['list'], ({ list }) => `[${list!.map((inner) => inner.toString()).join(', ')}]`)\n\ndefineMethod('object', ['dict'], ({ dict }) => {\n  if (Object.keys(dict!).length === 0) return '{}'\n  return `{ ${Object.entries(dict!).map(([key, inner]) => {\n    return `${key}${inner!.meta.required ? '' : '?'}: ${inner!.toString()}`\n  }).join(', ')} }`\n})\n\ndefineMethod('union', ['list'], ({ list }, inline) => {\n  const result = list!.map(({ toString: format }) => format()).join(' | ')\n  return inline ? `(${result})` : result\n})\n\ndefineMethod('intersect', ['list'], ({ list }) => {\n  return `${list!.map((inner) => inner.toString(true)).join(' & ')}`\n})\n\ndefineMethod('transform', ['inner', 'callback', 'preserve'], ({ inner }, isInner) => inner!.toString(isInner))\n\nexport = Schema\n", "import Schema from 'schemastery'\nimport { clone, deepEqual, Dict, difference, isNullable, union, valueMap } from 'cosmokit'\nimport { computed, getCurrentInstance, ref, watch, WatchStopHandle } from 'vue'\nimport { fallbackWithLocaleChain } from '@intlify/core-base'\nimport { useI18n } from 'vue-i18n'\nimport form from '.'\n\nexport { Schema }\n\nexport function useI18nText() {\n  const composer = useI18n()\n  const context: any = {}\n  return (message?: string | Dict<string>) => {\n    if (!message || typeof message === 'string') return message as string\n    const locales = fallbackWithLocaleChain(context, composer.fallbackLocale.value, composer.locale.value)\n    for (const locale of locales) {\n      if (locale in message) return message[locale]\n    }\n  }\n}\n\nconst dynamic = ['function', 'transform', 'is']\n\nexport function getChoices(schema: Schema) {\n  const inner: Schema[] = []\n  const choices = schema.list.filter((item) => {\n    if (item.meta.hidden) return\n    if (item.type === 'transform') inner.push(item.inner)\n    return !dynamic.includes(item.type)\n  })\n  return choices.length ? choices : inner\n}\n\nexport function getFallback(schema: Schema, required = false) {\n  if (!schema || schema.type === 'union' && getChoices(schema).length === 1) return\n  return clone(schema.meta.default) ?? (required ? inferFallback(schema) : undefined)\n}\n\nexport function inferFallback(schema: Schema) {\n  if (schema.type === 'string') return ''\n  if (schema.type === 'number') return 0\n  if (schema.type === 'boolean') return false\n  if (['dict', 'object', 'intersect'].includes(schema.type)) return {}\n}\n\nfunction optional(schema: Schema): Schema {\n  if (schema.type === 'const') return schema\n  if (schema.type === 'transform') return optional(schema.inner)\n  schema = new Schema(schema).required(false)\n  if (schema.type === 'object') {\n    schema.dict = valueMap(schema.dict, optional)\n  } else if (schema.type === 'tuple') {\n    schema.list = schema.list.map(optional)\n  } else if (schema.type === 'intersect') {\n    schema.list = schema.list.map(optional)\n  } else if (schema.type === 'union') {\n    schema.list = schema.list.map(optional)\n  } else if (schema.type === 'dict') {\n    schema.inner = optional(schema.inner)\n  } else if (schema.type === 'array') {\n    schema.inner = optional(schema.inner)\n  }\n  return schema\n}\n\nexport function check(schema: any, value: any) {\n  try {\n    optional(schema)(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport function explain(schema: Schema, value: any): readonly [string, any[]?] {\n  if (isNullable(value)) return\n  if (schema.type !== 'string') return\n  if (schema.meta.pattern) {\n    const { source, flags } = schema.meta.pattern\n    const regexp = new RegExp(source, flags)\n    if (!regexp.test(value)) {\n      return ['errors.regexp-not-matched', [regexp.toString()]]\n    }\n  }\n}\n\nexport function useDisabled() {\n  const { props } = getCurrentInstance() as any\n  return computed(() => props.disabled || props.schema?.meta?.disabled)\n}\n\ninterface ConfigOptions<T> {\n  strict?: boolean\n  input?(value: any): T\n  output?(value: T): any\n}\n\nexport function useModel<T = any>(options?: ConfigOptions<T>) {\n  let stop: WatchStopHandle\n  const config = ref<T>()\n  const { props, emit } = getCurrentInstance() as any\n\n  const doWatch = () => watch(config, (value) => {\n    try {\n      if (options?.output) value = options.output(value)\n      const schema = optional(Schema(props.schema))\n      if (deepEqual(schema(value), props.schema.meta.default, options?.strict)) value = null\n    } catch {\n      return\n    }\n    emit('update:modelValue', value)\n  }, { deep: true })\n\n  watch(() => [props.modelValue, props.schema], ([value, schema]) => {\n    stop?.()\n    value ??= getFallback(schema)\n    if (options?.input) value = options.input(value)\n    config.value = value\n    stop = doWatch()\n  }, { deep: true, immediate: true })\n\n  return config\n}\n\nexport function useEntries() {\n  const { props } = getCurrentInstance() as any\n\n  const entries = useModel<[string, any][]>({\n    strict: true,\n    input: (config) => {\n      const result = Object.entries(config)\n      if (props.schema.type === 'array') {\n        const padding = (props.schema.meta.min ?? 0) - result.length\n        for (let i = 0; i < padding; i++) {\n          result.push(['' + result.length, null])\n        }\n      }\n      return result\n    },\n    output: (config) => {\n      if (props.schema.type === 'array') {\n        return config.map(([, value]) => value)\n      }\n      const result: any = {}\n      for (const [key, value] of config) {\n        if (key in result) throw new Error('duplicate entries')\n        result[key] = value\n      }\n      return result\n    },\n  })\n\n  const isFixedLength = computed(() => {\n    return props.schema.meta.min && props.schema.meta.min === props.schema.meta.max\n  })\n\n  const isMax = computed(() => entries.value.length >= props.schema.meta.max)\n  const isMin = computed(() => entries.value.length >= props.schema.meta.max)\n\n  const reindex = () => {\n    if (props.schema.type !== 'array') return\n    for (let i = 0; i < entries.value.length; i++) {\n      entries.value[i][0] = '' + i\n    }\n  }\n\n  return {\n    entries,\n    isMax,\n    isMin,\n    isFixedLength,\n    up(index: number) {\n      if (props.schema.type === 'dict') {\n        entries.value.splice(index - 1, 0, ...entries.value.splice(index, 1))\n      } else {\n        const temp = entries.value[index][1]\n        entries.value[index][1] = entries.value[index - 1][1]\n        entries.value[index - 1][1] = temp\n      }\n      reindex()\n    },\n    down(index: number) {\n      if (props.schema.type === 'dict') {\n        entries.value.splice(index + 1, 0, ...entries.value.splice(index, 1))\n      } else {\n        const temp = entries.value[index][1]\n        entries.value[index][1] = entries.value[index + 1][1]\n        entries.value[index + 1][1] = temp\n      }\n      reindex()\n    },\n    del(index: number) {\n      entries.value.splice(index, 1)\n      reindex()\n    },\n    insert(index: number) {\n      entries.value.splice(index, 0, ['', null])\n      reindex()\n    },\n  }\n}\n\nfunction isConstUnion(schema: Schema) {\n  return schema.type === 'union' && schema.list.every(item => item.type === 'const')\n}\n\nexport function isMultiSelect(schema: Schema) {\n  if (schema.type === 'bitset') return true\n  if (schema.type === 'array') return isConstUnion(schema.inner)\n}\n\nexport function useMultiSelect() {\n  const { props } = getCurrentInstance() as any\n\n  const keys = computed(() => {\n    if (props.schema.type === 'bitset') {\n      return Object.keys(props.schema.bits)\n    } else if (props.schema.type === 'array') {\n      return props.schema.inner.list.map((item: any) => item.value)\n    }\n  })\n\n  const items = computed(() => {\n    if (props.schema.type === 'bitset') {\n      return Object.keys(props.schema.bits).map(key => Schema.const(key))\n    } else if (props.schema.type === 'array') {\n      return props.schema.inner.list\n    }\n  })\n\n  const values = useModel<string[]>({\n    input(value) {\n      if (!isMultiSelect(props.schema)) return value\n      if (isNullable(value)) return []\n      if (Array.isArray(value)) return value\n      return Object.entries(props.schema.bits)\n        .filter(([key, bit]) => value & bit as any)\n        .map(([key]) => key)\n    },\n    output(value) {\n      if (!isMultiSelect(props.schema)) return value\n      return value.sort((a, b) => {\n        const indexA = keys.value.indexOf(a)\n        const indexB = keys.value.indexOf(b)\n        if (indexA < 0) {\n          return indexB < 0 ? 0 : 1\n        } else {\n          return indexB < 0 ? -1 : indexA - indexB\n        }\n      })\n    },\n  })\n\n  return {\n    values,\n    items,\n    selectAll() {\n      values.value = union(values.value, keys.value)\n    },\n    selectNone() {\n      values.value = difference(values.value, keys.value)\n    },\n    toggle(key: string) {\n      if (values.value.includes(key)) {\n        values.value = values.value.filter(k => k !== key)\n      } else {\n        values.value = [...values.value, key]\n      }\n    },\n  }\n}\n\nfunction isValidColumn(schema: Schema): boolean {\n  return ['string', 'number', 'boolean'].includes(schema.type)\n    || isConstUnion(schema)\n    || isMultiSelect(schema)\n}\n\nfunction ensureColumns(entries: [string, Schema][]) {\n  entries = entries.filter(([, schema]) => !schema.meta.hidden)\n  if (entries.every(([, schema]) => isValidColumn(schema))) return entries\n}\n\nexport function toColumns(schema: Schema): [string, Schema][] {\n  if (isValidColumn(schema)) {\n    return [[null, schema]]\n  } else if (schema.type === 'tuple') {\n    return ensureColumns(Object.entries(schema.list))\n  } else if (schema.type === 'object') {\n    return ensureColumns(Object.entries(schema.dict))\n  }\n}\n", "import { App, Component } from 'vue'\nimport { Schema, toColumns, useDisabled, useEntries, useModel } from './utils'\nimport SchemaBase from './base.vue'\nimport Primitive from './primitive.vue'\nimport SchemaCheckbox from './extensions/checkbox.vue'\nimport SchemaGroup from './extensions/group.vue'\nimport SchemaIntersect from './extensions/intersect.vue'\nimport SchemaObject from './extensions/object.vue'\nimport SchemaRadio from './extensions/radio.vue'\nimport SchemaMultiSelect from './extensions/multiselect.vue'\nimport SchemaTable from './extensions/table.vue'\nimport SchemaTextarea from './extensions/textarea.vue'\nimport SchemaTuple from './extensions/tuple.vue'\nimport SchemaUnion from './extensions/union.vue'\nimport KBadge from './badge.vue'\nimport KSchema from './schema.vue'\nimport KForm from './form.vue'\n\nimport './styles/index.scss'\n\nconst extensions = new Set<form.Extension>()\n\nexport * from 'cosmokit'\n\nexport { Primitive }\nexport { Schema, useI18nText } from './utils'\n\nexport * from './icons'\n\nexport const form = Object.assign(SchemaBase, {\n  Form: KForm,\n  Badge: KBadge,\n  Schema: KSchema,\n  useModel,\n  useEntries,\n  useDisabled,\n  extensions,\n  install(app: App) {\n    app.provide('__SCHEMASTERY_EXTENSIONS__', extensions)\n    app.component('k-form', KForm)\n    app.component('k-badge', KBadge)\n    app.component('k-schema', KSchema)\n  },\n}) as typeof SchemaBase & {\n  Form: typeof KForm\n  Badge: typeof KBadge\n  Schema: typeof KSchema\n  useModel: typeof useModel\n  useEntries: typeof useEntries\n  useDisabled: typeof useDisabled\n  extensions: Set<form.Extension>\n  install: (app: App) => void\n}\n\nexport namespace form {\n  export interface Extension {\n    type: string\n    role?: string\n    validate?: (value: any, schema: Schema) => boolean\n    component: Component\n  }\n}\n\nform.extensions.add({\n  type: 'bitset',\n  role: 'select',\n  component: SchemaMultiSelect,\n  validate: value => typeof value === 'number' || Array.isArray(value) && value.every(v => typeof v === 'string'),\n})\n\nform.extensions.add({\n  type: 'array',\n  role: 'select',\n  component: SchemaMultiSelect,\n  validate: value => Array.isArray(value) && value.every(v => typeof v === 'string'),\n})\n\nform.extensions.add({\n  type: 'bitset',\n  component: SchemaCheckbox,\n  validate: value => typeof value === 'number' || Array.isArray(value) && value.every(v => typeof v === 'string'),\n})\n\nform.extensions.add({\n  type: 'array',\n  role: 'checkbox',\n  component: SchemaCheckbox,\n  validate: value => Array.isArray(value) && value.every(v => typeof v === 'string'),\n})\n\nform.extensions.add({\n  type: 'array',\n  component: SchemaGroup,\n  validate: value => Array.isArray(value),\n})\n\nform.extensions.add({\n  type: 'dict',\n  component: SchemaGroup,\n  validate: value => typeof value === 'object',\n})\n\nform.extensions.add({\n  type: 'object',\n  component: SchemaObject,\n  validate: value => typeof value === 'object',\n})\n\nform.extensions.add({\n  type: 'intersect',\n  component: SchemaIntersect,\n  validate: value => typeof value === 'object',\n})\n\nform.extensions.add({\n  type: 'union',\n  role: 'radio',\n  component: SchemaRadio,\n})\n\nform.extensions.add({\n  type: 'array',\n  role: 'table',\n  component: SchemaTable,\n  validate: (value, schema) => Array.isArray(value) && !!toColumns(schema.inner),\n})\n\nform.extensions.add({\n  type: 'dict',\n  role: 'table',\n  component: SchemaTable,\n  validate: (value, schema) => typeof value === 'object' && !!toColumns(schema.inner),\n})\n\nform.extensions.add({\n  type: 'string',\n  role: 'textarea',\n  component: SchemaTextarea,\n  validate: value => typeof value === 'string',\n})\n\nform.extensions.add({\n  type: 'tuple',\n  component: SchemaTuple,\n  validate: value => Array.isArray(value),\n})\n\nform.extensions.add({\n  type: 'union',\n  component: SchemaUnion,\n})\n\nexport default form\n", "import IconAdd from './add.vue'\nimport IconArrowDown from './arrow-down.vue'\nimport IconArrowUp from './arrow-up.vue'\nimport IconBranch from './branch.vue'\nimport IconClose from './close.vue'\nimport IconCode from './code.vue'\nimport IconCollapse from './collapse.vue'\nimport IconDelete from './delete.vue'\nimport IconEllipsis from './ellipsis.vue'\nimport IconExpand from './expand.vue'\nimport IconExternal from './external.vue'\nimport IconEyeSlash from './eye-slash.vue'\nimport IconEye from './eye.vue'\nimport IconInsertAfter from './insert-after.vue'\nimport IconInsertBefore from './insert-before.vue'\nimport IconInvalid from './invalid.vue'\nimport IconRedo from './redo.vue'\nimport IconReset from './reset.vue'\nimport IconSquareCheck from './square-check.vue'\nimport IconSquareEmpty from './square-empty.vue'\nimport IconUndo from './undo.vue'\n\nexport {\n  IconAdd,\n  IconArrowDown,\n  IconArrowUp,\n  IconBranch,\n  IconClose,\n  IconCode,\n  IconCollapse,\n  IconDelete,\n  IconEllipsis,\n  IconExpand,\n  IconExternal,\n  IconEyeSlash,\n  IconEye,\n  IconInsertAfter,\n  IconInsertBefore,\n  IconInvalid,\n  IconRedo,\n  IconReset,\n  IconSquareCheck,\n  IconSquareEmpty,\n  IconUndo,\n}\n", "import { App } from 'vue'\nimport form from 'schemastery-vue'\nimport Computed from './computed.vue'\nimport Filter from './k-filter.vue'\n\nform.extensions.add({\n  type: 'union',\n  role: 'computed',\n  component: Computed,\n})\n\nexport { form as SchemaBase }\n\nexport * from 'schemastery-vue'\n\nexport default function (app: App) {\n  app.use(form)\n  app.component('k-filter', Filter)\n}\n", "import { App } from 'vue'\nimport VirtualList from './list.vue'\n\nexport { VirtualList }\n\nexport default function (app: App) {\n  app.component('virtual-list', VirtualList)\n}\n", "import { App } from 'vue'\nimport form from './form'\nimport virtual from './virtual'\nimport Comment from './k-comment.vue'\nimport ImageViewer from './image-viewer.vue'\n\nimport './index.scss'\n\nexport * from 'cosmokit'\nexport * from './form'\nexport * from './virtual'\n\nexport default function (app: App) {\n  app.use(form)\n  app.use(virtual)\n  app.component('k-comment', Comment)\n  app.component('k-image-viewer', ImageViewer)\n}\n"],
  "mappings": "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",
  "names": ["value", "Binary", "a", "b", "Time", "template", "Schema", "__name", "options", "refs", "pattern", "value", "date", "key"]
}
